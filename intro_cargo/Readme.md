https://doc.rust-lang.org/book/ch01-03-hello-cargo.html

Cargo คือเครื่องมือ package manager และระบบ build สำหรับ Rust ที่ช่วยให้การสร้าง จัดการ dependencies และการทดสอบเป็นเรื่องง่ายขึ้น ในขณะที่ rustc (Rust compiler) เป็นตัว compile ที่แปลง code จาก Rust ไปเป็น binary file

ข้อดีของการใช้ Cargo

จัดการโครงการและสร้างโครงสร้างพื้นฐานอัตโนมัติ
จัดการ dependencies ได้ง่ายและอัตโนมัติ
Build และ run code ได้ในขั้นตอนเดียว
รองรับการทดสอบด้วยระบบในตัว
จัดการหลายเวอร์ชันของโปรเจกต์และ dependencies


cargo new <ชื่อ project>
cargo new intro_cargo

cargo build
cargo run

สามารถลง package ได้ผ่านคำสั่ง cargo install เช่น เราจะลองลง library ที่สามารถ watch file ได้ (file เปลี่ยน = build ใหม่ให้ auto)

# ลง library
cargo install cargo-watch

# ลอง run
cargo watch -x run


--------------------------------------------------------------------------------------------------------------------------------------------------------
https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html

พื้นฐานแรกของ Rust กันนั่นคือ Core Programming Concept ที่มีอยู่ในทุกภาษาอย่าง Variable, Data Type, Control Flow กันว่า ภาษา Rust มีหลักการพื้นฐานทางภาษาอย่างไรบ้าง

# Variable
Variable ใน Rust คือค่าที่ใช้เก็บข้อมูล โดยค่าในตัวแปรสามารถเปลี่ยนแปลงได้หากเราระบุให้ตัวแปรนั้นเป็น mutable (mut) มิฉะนั้นตัวแปรจะถือว่าเป็น “immutable (ค่าคงที่) โดยค่าเริ่มต้น”

โดย เหตุผลที่ Rust ใช้ immutable เป็นค่าเริ่มต้น นั้น เกิดจาก concept ของ Rust ที่กำหนดไว้ว่า

1.เพิ่มความปลอดภัยของ code ป้องกันไม่ให้โปรแกรมทำการเปลี่ยนแปลงค่าของตัวแปรโดยไม่ตั้งใจ ซึ่งอาจทำให้เกิดข้อผิดพลาดที่ยากจะตรวจพบ
2.ป้องกันการเข้าถึงข้อมูลพร้อมกันที่ไม่ปลอดภัย (Data Race) โดย Rust ให้ความสำคัญกับการเขียน code ที่รองรับการทำงานพร้อมกัน (concurrency) การใช้ตัวแปร immutable ทำให้มั่นใจได้ว่าหลาย ๆ thread สามารถอ่านค่าของตัวแปรได้พร้อมกัน โดยไม่ต้องกังวลว่าจะมีการเปลี่ยนแปลงค่าจาก thread อื่น


--------------------------------------------------------------------------------------------------------------------------------------------------------
# Data Type
Data Type ใน Rust หมายถึงประเภทของข้อมูลที่ใช้เก็บค่าในตัวแปร ซึ่งเป็นสิ่งที่ช่วยกำหนดประเภทของข้อมูล เช่น ตัวเลข, ตัวอักษร, Boolean ฯลฯ Rust มีการจัดการประเภทข้อมูลอย่างเข้มงวด ซึ่งช่วยเพิ่มความปลอดภัยและประสิทธิภาพ

ประเภทของตัวแปร ใน Rust มีการแบ่งในแต่ละกลุ่ม โดยจะมี 2 กลุ่มหลักๆคือ

1.Scalar Types (ประเภทข้อมูลเดี่ยว) เป็นประเภทข้อมูลที่แทนค่าหนึ่งค่า Rust มี 4 ชนิด คือ Integers, Floating-Point Numbers, Booleans, และ Characters

2.Compound Types ประเภทข้อมูลที่ใช้จัดกลุ่มค่าหลาย ๆ ค่าเข้าด้วยกัน Rust มี Compound Types หลัก 2 ประเภท คือ Tuples และ Arrays

## นอกจากประเภทข้อมูลพื้นฐานที่กล่าวมา Rust ยังมีประเภทข้อมูลเพิ่มเติมที่มาจาก Standard Library ซึ่งมักถูกใช้ในโปรแกรม เช่น Strings, Slice และ Vectors

3.String Types ประเภทข้อความสำหรับเก็บอักขระหลายตัว ประเภท String มาจาก Standard Library ของ Rust ไม่ได้ถูกเขียนในภาษาโดยตรง

4.Slice (การอ้างอิงบางส่วนของ array) Slice เป็นการอ้างอิงบางส่วนของข้อมูล เช่นการอ้างอิงช่วงของ array

5.Vector ใช้สำหรับจัดเก็บค่าหลายค่าที่สามารถปรับเปลี่ยนจำนวนได้


--------------------------------------------------------------------------------------------------------------------------------------------------------
# Operator

ประเภทของ Operators ใน Rust

1.Arithmetic Operators (ตัวดำเนินการทางคณิตศาสตร์) ใช้ในการคำนวณทางคณิตศาสตร์ระหว่างตัวเลข
+ : บวก
- : ลบ
* : คูณ  
/ : หาร
% : หารเอาเศษ (modulo)

2.Comparison Operators (ตัวดำเนินการเปรียบเทียบ) ใช้เปรียบเทียบค่าระหว่างตัวแปรหรือค่าต่าง ๆ และให้ผลลัพธ์เป็น true หรือ false
== : เท่ากับ
!= : ไม่เท่ากับ
> : มากกว่า
< : น้อยกว่า
>= : มากกว่าหรือเท่ากับ
<= : น้อยกว่าหรือเท่ากับหรือเท่ากับ

3.Logical Operators (ตัวดำเนินการทางตรรกะ) ใช้ในการทำงานกับค่าบูลีน (true หรือ false)
&& : และ (AND)
|| : หรือ (OR)
! : ไม่ (NOT)

4.Bitwise Operators (ตัวดำเนินการระดับบิต) ใช้ในการทำงานกับข้อมูลในระดับบิต
& : AND บิต
| : OR บิต
^ : XOR บิต
<< : เลื่อนบิตไปทางซ้าย
>> : เลื่อนบิตไปทางขวา    

5.Assignment Operators (ตัวดำเนินการกำหนดค่า) ใช้ในการกำหนดค่าลงในตัวแปร
= : กำหนดค่า
+= : บวกและกำหนดค่า
= : ลบและกำหนดค่า
= : คูณและกำหนดค่า
/= : หารและกำหนดค่า
%= : หารเอาเศษและกำหนดค่า

6.Range Operators (ตัวดำเนินการช่วง) ใช้ในการกำหนดช่วงตัวเลข
.. : ไม่รวมค่าปลายทาง
..= : รวมค่าปลายทาง


--------------------------------------------------------------------------------------------------------------------------------------------------------
# Function
Function ใน Rust คือกลุ่มของ code ที่ถูกรวมไว้ด้วยกันเพื่อทำงานบางอย่าง โดยสามารถรับค่า input (parameter) และส่งผลลัพธ์ออกมาได้ (return value) การใช้ function ช่วยในการจัดระเบียบ code ลดการทำงานซ้ำ และทำให้ code อ่านง่ายขึ้น

คุณสมบัติของ Function ใน Rust

1.ความปลอดภัยในหน่วยความจำ: Rust ตรวจสอบความถูกต้องของการส่งคืนค่าและการจัดการหน่วยความจำ ทำให้มั่นใจได้ว่า function ทำงานได้อย่างถูกต้อง
2.ไม่มีการจัดการค่าที่เป็น Null: Rust ไม่อนุญาตให้มี null ในการส่งค่ากลับจาก function ซึ่งช่วยลดข้อผิดพลาดจากการใช้ค่าที่เป็น Null
3.สามารถใช้ function แบบ Recursion ได้: function สามารถเรียกตัวเองซ้ำได้ (recursive functions) เพื่อแก้ปัญหาบางประเภทที่ซับซ้อน

# Control Flow
Control Flow ใน Rust เป็นโครงสร้างที่ช่วยให้โปรแกรมของคุณตัดสินใจเลือกแนวทางการทำงานตามเงื่อนไขต่าง ๆ ตัวอย่างที่นิยมใช้คือ if, else if, else และ match โดยแต่ละโครงสร้างมีรูปแบบการใช้งานแตกต่างกันเล็กน้อย

# Loop
loop เป็นคำสั่งที่ช่วยให้เราทำการวนซ้ำ (loop) การทำงานใน แนกำ โดยมีรูปแบบการใช้งานที่หลากหลาย เช่น loop, while, และ for แต่ละแบบมีจุดประสงค์ที่แตกต่างกันเล็กน้อย


--------------------------------------------------------------------------------------------------------------------------------------------------------
# Ownership, Borrowing, and References
https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html

ทีนี้ หลายคนก็อาจจะสงสัยว่า “Garbage Collector คืออะไร และทำไม Rust ไม่ต้องใช้ Garbage Collector ได้”

- Garbage Collector (GC) คือโปรแกรมที่ทำหน้าที่จัดการการจัดสรรและคืนหน่วยความจำในภาษาโปรแกรมต่าง ๆ โดยในภาษาที่มี GC นักพัฒนาไม่จำเป็นต้องจัดการคืนหน่วยความจำเองหลังจากใช้งานเสร็จ เนื่องจาก GC จะทำการระบุและเรียกคืนหน่วยความจำที่ไม่ได้ใช้งานโดยอัตโนมัติ ซึ่งช่วยป้องกันปัญหา memory leaks (การสูญเสียหน่วยความจำโดยไม่จำเป็น)
-แต่ อย่างไรก็ตาม Rust ไม่มีระบบ Garbage Collector แต่ใช้กลไกที่เรียกว่า ownership ซึ่งเป็นคุณสมบัติเฉพาะตัวของ Rust ที่ช่วยรับประกันความปลอดภัยของหน่วยความจำโดยไม่ต้องพึ่งพา GC
--การทำงานของระบบ Ownership ใน Rust จะมีไอเดียหลักประมาณนี้
* แต่ละค่าจะมีตัวแปรหนึ่งตัวที่เป็นเจ้าของ (owner)
* ค่าหนึ่ง ๆ สามารถมี owner ได้เพียงหนึ่งตัวเท่านั้นในเวลาใดเวลาหนึ่ง
* เมื่อ owner หลุดออกจาก scope ค่านั้นจะถูกจัดการ (dropped)
--เมื่อรวมกับกฎการยืมหน่วยความจำ (borrowing rules) ระบบนี้ช่วยป้องกันปัญหาต่าง ๆ เช่น dangling pointers (พอยน์เตอร์ที่ชี้ไปยังหน่วยความจำที่ไม่ได้ใช้งานแล้ว) และ data races (การเข้าถึงข้อมูลพร้อมกันโดยไม่ปลอดภัย) เอาไว้ได้
--ระบบ Ownership, Borrowing, และ References เป็นกลไกหลักที่จัดการหน่วยความจำ (memory) เพื่อให้แน่ใจว่าโปรแกรมจะปลอดภัยจากปัญหาต่าง ๆ เช่น null pointer หรือ data race โดยไม่จำเป็นต้องใช้ garbage collector แนวคิดเหล่านี้ช่วยให้ Rust มีประสิทธิภาพในการจัดการหน่วยความจำขณะที่ยังคงความปลอดภัยในเวลาคอมไพล์ (compile-time)


## Ownership
ใน Rust ทุกค่าจะมี “เจ้าของเดียว” และเมื่อเจ้าของนั้นสิ้นสุด scope หน่วยความจำที่จัดสรรไว้สำหรับค่าดังกล่าวจะถูกปล่อย (freed) ทันทีโดยอัตโนมัติ นี่คือหลักการของ Ownership

กฎพื้นฐานของ Ownership

1.ในแต่ละเวลาจะมี “เจ้าของ” สำหรับค่าหนึ่ง ๆ ได้เพียงตัวเดียว
2.เมื่อเจ้าของถูกย้าย (moved) ค่าเดิมจะไม่สามารถถูกใช้งานได้อีก
3.เมื่อ scope ของเจ้าของหมด หน่วยความจำที่ใช้จะถูกปล่อยทันที

##  Borrowing
เพื่อหลีกเลี่ยงการย้ายความเป็นเจ้าของ เราสามารถ “ยืม” ค่าโดยใช้การอ้างอิง (references) การยืมทำให้เราสามารถใช้ค่าหนึ่งได้โดยไม่ต้องย้าย ownership

กฎพื้นฐานของ Borrowing

1.เราสามารถยืมค่าผ่าน reference ได้โดยใช้ &
2.การยืมค่าจะมีสองแบบ: ยืมแบบอ่าน (&T) และยืมแบบแก้ไข (&mut T)
3.ยืมแบบอ่านสามารถมีหลายครั้งพร้อมกันได้ แต่ “ยืมแบบแก้ไขต้องมีได้เพียงครั้งเดียว” ในเวลาเดียวกัน


## References
References คือการยืมค่าผ่านการอ้างอิง โดยเราสามารถใช้เครื่องหมาย & เพื่อสร้าง reference สำหรับค่าที่เราต้องการใช้ชั่วคราวโดยไม่ต้องย้ายความเป็นเจ้าของ

1.Immutable References (&T): ยืมแบบอ่านได้อย่างเดียว เราไม่สามารถเปลี่ยนแปลงค่าของข้อมูลที่ถูกยืมได้
2.Mutable References (&mut T): ยืมแบบที่สามารถเปลี่ยนแปลงค่าได้ แต่สามารถยืมแบบนี้ได้เพียงครั้งเดียวในเวลาเดียวกันเท่านั้น

- ข้อจำกัดของ References
1.เราไม่สามารถยืม mutable reference และ immutable reference พร้อมกันได้


--------------------------------------------------------------------------------------------------------------------------------------------------------
# Structs
https://doc.rust-lang.org/book/ch05-00-structs.html

Structs เป็นโครงสร้างข้อมูลที่ช่วยให้เรากำหนดประเภทข้อมูลที่ซับซ้อนมากกว่าการใช้ชนิดข้อมูลพื้นฐาน เช่น สามารถใช้เก็บหลาย ๆ ข้อมูลภายใต้โครงสร้างเดียวกัน คล้ายกับ “class” ในภาษาอื่น ๆ แต่ไม่มี method ภายในตัวโดยตรง (method จะถูกกำหนดแยกต่างหาก)

- Rust มี Structs สามประเภท
1.Classic Structs: โครงสร้างทั่วไปที่มีฟิลด์หลายแบบ
2.Tuple Structs: Struct แบบ Tuple ที่สามารถเข้าถึงฟิลด์ได้ผ่าน index
3.Unit Structs: Struct ที่ไม่มีฟิลด์ใด 


--------------------------------------------------------------------------------------------------------------------------------------------------------
# Enums
https://doc.rust-lang.org/book/ch06-00-enums.html

Enums เป็นประเภทข้อมูลที่สามารถเก็บค่าในหลายรูปแบบได้ภายใต้โครงสร้างเดียวกัน คล้ายกับ Union ในภาษาอื่น ๆ โดย Enums ช่วยให้เราเก็บค่าในรูปแบบที่แตกต่างกันแต่เป็นประเภทข้อมูลเดียวกันได้อย่างชัดเจนและปลอดภัย


--------------------------------------------------------------------------------------------------------------------------------------------------------
# Error Handling
https://doc.rust-lang.org/book/ch09-00-error-handling.html

Error Handling ใน Rust เป็นแนวคิดที่สำคัญในการจัดการกับสถานการณ์ที่ไม่คาดคิดหรือการทำงานผิดพลาดในโปรแกรม โดย Rust ใช้รูปแบบการจัดการข้อผิดพลาดที่ชัดเจนและปลอดภัยจากการทำงานผิดพลาดที่อาจเกิดขึ้นใน runtime ซึ่งจะทำให้โปรแกรมมีความเสถียรและสามารถจัดการกับสถานการณ์เหล่านั้นได้อย่างถูกต้อง

Rust ใช้โครงสร้างข้อมูลหลัก 2 ชนิดในการจัดการข้อผิดพลาด

Result<T, E>: ใช้สำหรับข้อผิดพลาดที่สามารถคาดการณ์ได้
panic!: ใช้สำหรับข้อผิดพลาดที่ไม่สามารถกู้คืนได้

Note: ควรหลีกเลี่ยงการใช้ panic! ในกรณีที่เราสามารถจัดการกับข้อผิดพลาดได้ เพราะ Rust ต้องการให้โปรแกรมจัดการข้อผิดพลาดด้วยการใช้ Result เพื่อให้โปรแกรมมีความทนทานต่อข้อผิดพลาดที่อาจเกิดขึ้นได้

บทสรุป Error Handling

 - Result<T, E>: ใช้สำหรับจัดการข้อผิดพลาดที่สามารถคาดการณ์ได้ เช่น การอ่านไฟล์ การทำงานกับ I/O หรือการคำนวณที่อาจมีข้อผิดพลาด
 - panic!: ใช้ในกรณีที่เกิดข้อผิดพลาดร้ายแรงที่ไม่สามารถกู้คืนได้ และควรใช้ในกรณีที่โปรแกรมไม่สามารถดำเนินการต่อได้

    feature การจัดการข้อผิดพลาดของ Rust ถูกออกแบบมาเพื่อช่วยให้คุณเขียน code ที่มีความเสถียรมากขึ้น panic! macro เป็นสัญญาณบอกว่าโปรแกรมของคุณอยู่ในสถานะที่ไม่สามารถจัดการได้ และช่วยให้คุณสั่งให้กระบวนการหยุดทำงานแทนที่จะพยายามดำเนินการต่อด้วยค่าที่ไม่ถูกต้องหรือผิดพลาด ส่วน Result enum ใช้ระบบประเภทของ Rust เพื่อบ่งบอกว่าการดำเนินการบางอย่างอาจล้มเหลว ซึ่ง code ของคุณอาจกู้คืนได้ คุณสามารถใช้ Result เพื่อบอก code ที่เรียก code ของคุณว่าจำเป็นต้องจัดการความเป็นไปได้ของความสำเร็จหรือความล้มเหลว การใช้ panic! และ Result ในสถานการณ์ที่เหมาะสมจะทำให้ code ของคุณมีความน่าเชื่อถือมากขึ้นเมื่อเกิดปัญหาที่หลีกเลี่ยงไม่ได้


--------------------------------------------------------------------------------------------------------------------------------------------------------
# Option
Option<T> เป็นประเภทข้อมูลที่ใช้จัดการกับค่าที่อาจจะมีหรือไม่มี โดยมีความคล้ายคลึงกับ Result<T, E> แต่ถูกออกแบบมาเพื่อใช้กับสถานการณ์ที่ไม่จำเป็นต้องจัดการกับข้อผิดพลาดอย่างเป็นทางการ เช่น ในกรณีที่เราต้องการแสดงให้เห็นว่าค่าหนึ่งอาจจะ “มีค่า” หรือ “ไม่มีค่า” (null-like) ซึ่งทำให้หลีกเลี่ยงปัญหาของการใช้งานค่า null ที่ไม่ปลอดภัยในภาษาอื่น ๆ